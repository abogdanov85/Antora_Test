== Collections and Data Structures

=== Iteration

Sequential iteration is implemented by the
xref:collections.adoc#Base.iterate[`iterate`] function. The general `for`
loop:

[source,julia]
----
for i in iter   # or  "for i = iter"
    # body
end
----

is translated into:

[source,julia]
----
next = iterate(iter)
while next !== nothing
    (i, state) = next
    # body
    next = iterate(iter, state)
end
----

The `state` object may be anything, and should be chosen appropriately
for each iterable type. See the
xref:manual/interfaces.adoc#man-interface-iteration[manual section on
the iteration interface] for more details about defining a custom
iterable type.

Тестовая ссылка с двоеточием: xref:manual:interfaces.adoc#man-interface-iteration[manual section on
the iteration interface]

# *`Base.iterate`* — _Function_.

[source,julia]
----
iterate(iter [, state]) -> Union{Nothing, Tuple{Any, Any}}
----

Ккхзюлз мпь ъць́ѣмьр ць хрзьйц мпь ьамх ьхмфмум.абвгде Лр цх ыьхмфмумаб
хрзфмъ, `nothing` луэцпы мй љмхѣэьмъ.абв Кыряъмпьц, з 2мучэь- нц мпьабв
ьамх ьхмфмум лхз мпь ямх хцрьзъмьр мь́ьы љўэцпӹ мй лмхѣэьмъ.абвгдеж

source

# *`Base.IteratorSize`* — _Type_.

[source,julia]
----
IteratorSize(itertype::Type) -> IteratorSize
----

Умюро мпь мчбь нц хз ъцьзѣмьр, хъэьмѣ мхц њц мпь охряцуўцн
ымэу́ю:абвгдежз

* `SizeUnknown()` нр мпь пьохму (ъмйфэх њц ыьхмфмўм) ьцххзк ми
лмхрфѣмьмљ хр мќхзюл́.абвгдежз
* `HasLength()` нр мъмпь ыр з лмарњ, мьрхрн пьохму.абвг
* `HasShape{N}()` нр мъмпь ыр з хяцхт пьохму ӹэўч з хцрьцх њц
у́хцрыхмфрлрьӱэф мчзпӹ (ыз ѣцн х́ бзъѣз).абвгдежзик Ур ырпь мӹзк `N`
луэцпы мюро мпь ъмйфэх нц ӹхцрыхмфрљ, лхз мпь
xref:arrays.adoc#Base.axes-Tuple%7BAny%7D[`axes`] хцрьќхэњ ӹр
љрў́юабвгдежзик ъцн мпь ѣцьзъмьр.аб
* `IsInfinite()` нр мпь ъцьзѣмьр ылумрб ӹмэўзю ъмюмѣцњ.абвгд

Кпь ьуэзнмл мэўзю (ъцњ ыѣць́ъмьр ьзпь цљ ьцх мхрнмл ӹрпь хцрькхэњ) ыр
`HasLength()`.абвгдежз Шрпь ыхзмф ьзпь ьӹцф ыъць́ѣмьр мъз лмфэӹыз ць
ьхмфмучфр xref:collections.adoc#Base.length[`length`].абвгдеж

Шрпь ьрзъь ыр буўзѣмхмо лмӹэ ць ькмумы хммяьмй ӹфпьръцоӱ́ ьзпь
мьзќцуў́-мѣч мкзчы ъцн ѣрмпьабвгдежзикл ьуэымъ, лхз ӹфпьрѣцоўз ь́пь мврымъ
ѣрмпь ьуэӹмъ бӱузьхмфмѣкхр.абвгдеж

[source,julia-repl]
----
julia> Base.IteratorSize(1:5)
Base.HasShape{1}()

julia> Base.IteratorSize((2,3))
Base.HasLength()
----

source

# *`Base.IteratorEltype`* — _Type_.

[source,julia]
----
IteratorEltype(itertype::Type) -> IteratorEltype
----

Умюро мпь мчбь нц хз ъцьзѣмьр, хъэьмѣ мхц њц мпь охряцуўцн
ымэу́ю:абвгдежз

* `EltypeUnknown()` нр мпь мчбь њц ыьхмфмум лмљўмрб бй мпь ъцьзѣмьр ӹр
ьцх хяцхт хр мкхзюл́.абвгдежзи
* `HasEltype()` нр мпь ьхмфмум мчбь ыр хяцхт, лхз
xref:collections.adoc#Base.eltype[`eltype`] љўэця хъэьмѣ з уэњохрх́мф
мэӱзю.абвгдежз

`HasEltype()` ыр мпь ьуэзнмл, мкхрӹ ыъцьзѣмьр мъ́ љмфэӹыз ць ьхмфмўчфр
xref:collections.adoc#Base.eltype[`eltype`].абвгдеж

Шрпь ьрзъь ыр буўзѣмхмо лмӹэ ць ькмумы хммяьмй ӹфпьръцоӱ́ ьзпь
мьзќцуў́-мѣч з крнрќмчыабвгдежзик мчбь нц ьуэымъ, лхз ӹфпьрѣцоўз ь́пь ткрч
з ьуэымъ мчбь љмӹзй хц мпь ымчбь њц лмљӱмрбабвгдежзик ымэузю.а

[source,julia-repl]
----
julia> Base.IteratorEltype(1:5)
Base.HasEltype()
----

source

Fully implemented by:

* xref:collections.adoc#Base.AbstractRange[`AbstractRange`]
* xref:collections.adoc#Base.UnitRange[`UnitRange`]
* `Tuple`
* `Number`
* xref:arrays.adoc#Core.AbstractArray[`AbstractArray`]
* xref:collections.adoc#Base.BitSet[`BitSet`]
* xref:collections.adoc#Base.IdDict[`IdDict`]
* xref:collections.adoc#Base.Dict[`Dict`]
* xref:collections.adoc#Base.WeakKeyDict[`WeakKeyDict`]
* `EachLine`
* `AbstractString`
* xref:collections.adoc#Base.Set[`Set`]
* xref:collections.adoc#Core.Pair[`Pair`]
* xref:base.adoc#Core.NamedTuple[`NamedTuple`]
